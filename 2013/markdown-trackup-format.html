
<p>Comment gérer l’évolution d’une application, en traçant l’historique des versions, tout en planifiant une roadmap, mais également les fonctionnalités en cours de développement ? </p>
<p>Oh bien sûr, il existe des dizaines de façons d’aborder ce problème, mais aucune ne me convient vraiment. Le gestionnaire de tâches généraliste est pratique, mais peu adapté. Le bugtracker est pertinent pour les corrections, mais gère mal les features de haut niveau. GitHub, comme toujours, propose des outils intéressants. Mais entre les “issues”, les “milestones” et maintenant les “releases”, l’ensemble manque de cohérence à mon goût. </p>
<p>Permettez-moi de faire mon <a href="http://daringfireball.net/colophon/">Gruber</a> le temps de cet article, pour proposer un format simple, qui permettrait de régler ce problème tout en encourageant le développement d’outils pour en faciliter l’utilisation dans divers contextes. Je vous présente “Trackup”.</p>
<p>Tout le monde aime <a href="http://daringfireball.net/projects/markdown/">Markdown</a> (en tout cas, je n’ai jamais entendu quelqu’un s’en plaindre). Gardons donc les bonnes idées : un simple fichier texte, avec une syntaxe “naturelle” et lisible. Voilà ce que ça pourrait donner pour tracer des features :</p>

<code>
# InstaMétéoVetica<br/>
<br/>
Description générale facultative…<br/>
<br/>
## Roadmap<br/>
<br/>
- Mise à jour pour iOS 8<br/>
- Affichage de la température<br/>
<br/>
## 1.2<br/>
<br/>
- [X] Mise à jour pour iOS 7<br/>
- [ ] Re-nouvelle icône<br/>
<br/>
## 1.1<br/>
<br/>
_2013-02-01_<br/>
<br/>
- Prévisions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- Connexion à l’API<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- Stockage des données<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- Nouvelle vue<br/>
- Nouvelle icône<br/>
- Correction de bugs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- Bug #1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- Bug #2<br/>
<br/>
## 1.0<br/>
<br/>
_2013-01-01_<br/>
<br/>
Description propre à la version, liens de téléchargement, toujours facultatifs…<br/>
<br/>
- Calcul des données<br/>
- Jolie interface<br/>
</code>

<p>L’ordre des versions est antéchronologique, comme souvent pour les changelogs. On peut facilement étendre les données en ajoutant des dates, des liens et des descriptions. Possibilité de créer des sous-listes, ça peut toujours être pratique. </p>
<p>Au final, c’est donc bien un fichier Markdown. C’est la beauté de la chose : tous les éditeurs correspondants sont directement compatibles. Mais alors pourquoi <strong>encore</strong> une nouvelle sur-syntaxe à Markdown ? Parce que celle-ci répond à un besoin bien particulier, en tout cas pour moi. </p>
<p>Un tel fichier placé à la racine d’un repository hébergé sur GitHub bénéficiera d’une mise en forme et d’un moteur d’édition en ligne très poussés. Et ce n’est que le début. Si je trouve un peu de temps libre, ou si quelqu’un est intéressé, il serait possible de développer une (des) application(s) pour lire et écrire ce genre de fichiers. Pouvoir cocher les features lorsqu’elles sont prêtes, réorganiser les éléments par drag-n-drop, se connecter à l’API GitHub pour créer les releases automatiquement, etc. </p>
<p>Dernière proposition : utiliser l’extension <code>.tu.md</code>. Oui, c’est un peu moche, mais ce serait dommage de se priver de la prise en charge Markdown, et ce serait triste sans une extension dédiée. N’hésitez surtout pas à partager vos commentaires, je serais ravi de mettre à jour cet article avec vos retours.</p>
